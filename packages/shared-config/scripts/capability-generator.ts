#!/usr/bin/env tsx
import camelCase from 'camelcase';
import { execa } from 'execa';
import * as fse from 'fs-extra';
import { globby } from 'globby';

async function getBinNames(): Promise<string[]> {
  const paths = await globby('../*/package.json', { ignore: ['../shared-config/package.json'] });

  // Add the bin names for each package (except shared-)
  const names: string[] = [];
  for (const path of paths) {
    const packageJson = (await fse.readJSON(path)) as Record<string, unknown>;
    const bin = packageJson.bin as Record<string, string> | undefined;

    if (bin) {
      for (const name of Object.keys(bin)) {
        names.push(name);
      }
    } else {
      console.error(`No bin key found in package.json for ${path}`);
      process.exit(1);
    }
  }

  return names;
}

async function getCapabilities(binName: string): Promise<string[]> {
  const helpText = await execa(binName, ['--help']);

  if (helpText.exitCode !== 0 || helpText.stdout === undefined || helpText.stdout.length === 0) {
    console.error(`Error getting capabilities for ${binName}`);
    process.exit(1);
  }

  const capabilities: string[] = [];
  for (const match of helpText.stdout.matchAll(/--([a-z-]+)/g)) {
    capabilities.push(camelCase(match[1]));
  }

  return capabilities;
}

type Capabilities = Record<string, string[]>;

const capabilities: Capabilities = {};
for (const binName of await getBinNames()) {
  for (const capability of await getCapabilities(binName)) {
    capabilities[capability] = [...(capabilities[capability] ?? []), binName];
  }
}

const capabilitiesModule = `// Generated by capability-generator.ts\nexport const capabilities = ${JSON.stringify(
  capabilities,
  undefined,
  2,
)};`;

await fse.mkdir('./build', { recursive: true });
await fse.writeFile('./build/capabilities.ts', capabilitiesModule);
