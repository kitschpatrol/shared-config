#!/usr/bin/env tsx
import camelCase from 'camelcase'
import { execa } from 'execa'
import fse from 'fs-extra'
import { globby } from 'globby'

async function getBinNames(): Promise<string[]> {
	const paths = await globby('../*/package.json', { ignore: ['../shared-config/package.json'] })

	// Add the bin names for each package (except shared-)
	const names: string[] = []
	for (const path of paths) {
		const packageJson = (await fse.readJSON(path)) as Record<string, unknown>
		const bin = packageJson.bin as Record<string, string> | undefined

		if (bin) {
			for (const name of Object.keys(bin)) {
				names.push(name)
			}
		} else {
			console.error(`No bin key found in package.json for ${path}`)
			process.exit(1)
		}
	}

	return names
}

async function getCapabilities(binName: string): Promise<string[]> {
	const helpText = await execa(binName, ['--help'], {
		localDir: process.cwd(),
		preferLocal: true,
	})

	if (helpText.exitCode !== 0 || helpText.stdout === undefined || helpText.stdout.length === 0) {
		console.error(`Error getting capabilities for ${binName}`)
		process.exit(1)
	}

	const capabilities: string[] = []

	// Find all flags that start with two spaces and two dashes
	for (const match of helpText.stdout.matchAll(/ {2}--([a-z-]+)/g)) {
		capabilities.push(camelCase(match[1]))
	}

	// Find all subcommands
	for (const match of helpText.stdout.matchAll(new RegExp(`  ${binName} ([a-z-]+) `, 'g'))) {
		capabilities.push(camelCase(match[1]))
	}

	return capabilities
}

type Capabilities = Record<string, string[]>

const capabilities: Capabilities = {}
for (const binName of await getBinNames()) {
	for (const capability of await getCapabilities(binName)) {
		capabilities[capability] = [...(capabilities[capability] ?? []), binName]
	}
}

const capabilitiesModule = `// Generated by capability-generator.ts\nexport const capabilities = ${JSON.stringify(
	capabilities,
	undefined,
	2,
)};`

await fse.mkdir('./build', { recursive: true })
await fse.writeFile('./build/capabilities.ts', capabilitiesModule)
